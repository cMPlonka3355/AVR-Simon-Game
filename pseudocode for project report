; Pseudocode for Project, basic outline

.equ DELAY_S = 64                       ; sleep 1 second

.org 0x0000
          jmp       main
          
; ------------------------------------------------------------
main:
; main application method
;         one-time setup & configuration

; set ups for output and input
                                 ; setup 4 pins for output to light
	sbi	DDRB, DDB0	 ; LED 1
	sbi	DDRB, DDB1       ; LED 2
	sbi	DDRB, DDB2       ; LED 3
	sbi	DDRB, DDB3       ; LED 4

				; set 4 light pins to low voltage
	cbi     PORTB, PB0	
	cbi     PORTB, PB1
	cbi     PORTB, PB2
	cbi     PORTB, PB3
	
				; setup different 4 pins for input to the machine, to match light
	cbi	DDRD, DDD0	; Button 1
	cbi	DDRD, DDD1	; Button 2
	cbi	DDRD, DDD2	; Button 3
	cbi	DDRD, DDD3	; Button 4
	
;setup connection with 4 digit display, to keep track of score
	
	ldi	r31, 50		;set variable for length of pattern to 50 default
	
	ldi	r30, 0		;set up variable for keeping track of score
	
	ldi	r29, 0x0061	;set up starting address in extended I/O to save pattern in

generate_pattern:
;generates pattern to be utilized in gameplay loop
	mov	r1, r29		;copy address to other gpr, in order to increment in loop

				;random generation of value between 1 and 4, assigned to gpr address
	cpi	r17, 0			;switch statement determining which signal to save into pattern list
	breq	save_PD0_on_into_pattern
	
	cpi	r17, 1			;switch statement determining which signal to save into pattern list
	breq	save_PD1_on_into_pattern
	
	cpi	r17, 2			;switch statement determining which signal to save into pattern list
	breq	save_PD2_on_into_pattern
	
	cpi	r17, 3			;switch statement determining which signal to save into pattern list
	breq	save_PD3_on_into_pattern
	
continue_pattern_generation:
	inc	r1		;increment to next address in I/O
				;loop for total of 50 times

; ------------------------------------------------------------
	
main_gameplay_loop:
                               
four_button_press:                      
;the purpose of four_button_press is to take button input, turn led on, turn led off                                   
          in        r16,PORTD           ; copy the entire D port into r16     
          cpi       PD0,1               ; use CPI to check if Port D Pin 0 (button1) is set (pressed)
          breq      button_one_pressed  ; if pressed branch
          cpi       PD1,1               ; use CPI to check if Port D Pin 1 (button2) is set (pressed) 
          breq      button_two_pressed
          cpi       PD2,1               ; use CPI to check if Port D Pin 2 (button3) is set (pressed)
          breq      button_three_pressed
          cpi       PD3,1               ; use CPI to check if Port D Pin 3 (button4) is set (pressed)
          breq      button_four_pressed
          rjmp      four_button_press
button_one_pressed:
          sbi       PORTB,PB0           ; turn LED 1 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB0           ; turn LED 1 off
          rjmp      end_fbpress
button_two_pressed:
          sbi       PORTB,PB1           ; turn LED 2 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB1           ; turn LED 2 off
          rjmp      end_fbpress
button_three_pressed:
          sbi       PORTB,PB2           ; turn LED 3 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB2           ; turn LED 3 off
          rjmp      end_fbpress
button_4_pressed:
          sbi       PORTB,PB3           ; turn LED 4 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB3           ; turn LED 4 off
          rjmp      end_fbpress
end_fbpress:
                            
	;get random value that corresponds to four options for pattern input and output
	
	;set specific memory address as one to start pattern from
	
	;assign value into memory, making sure it's to next place in memory for pattern
	;	-something along lines of certain memory register + (pattern length - 1)
	
	;increment length variable
	
	;set variable for keep track of loop as zero
	
	;display value of score

display_pattern: 
	;do: fetch value from memory using first memory + (pattern length - 1)
	;display value by turning on corresponding light
	;delay
	;turn light off
	;increment variable to track loop
	;while (loop tracker < pattern length), jump to display_pattern
	
	;set loop variable back to zero

player_repeat_pattern:
	;do: fetch value from memory using first memory + (pattern length - 1)
	;have player input value
	;display light as on
	;compare player input to value from memory
	;if not same value, jump to lose state
	;else continue loop
	;increment variable tracker
	;while (loop tracker < pattern length), jump to player_repeat_pattern
	
	;increment score

end_main:
	rjmp	main_gameplay_loop

lose_game:
	rjmp	lose_game

; ------------------------------------------------------------
delay_ms:
; creates a timed delay using multiple nested loops (utilized from GPIO tutorials)
; ------------------------------------------------------------
          ldi       r18,DELAY_S
delay_ms_1:

          ldi       r17,200
delay_ms_2:

          ldi       r16,250
delay_ms_3:
          nop
          nop
          dec       r16
          brne      delay_ms_3          ; 250 * 5 = 1250

          dec       r17
          brne      delay_ms_2          ; 200 * 1250 = 250K

          dec       r18
          brne      delay_ms_1          ; 16 * 250K = 4M (1/4s ex)
dealy_ms_end:
          ret
