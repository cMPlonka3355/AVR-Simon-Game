; Pseudocode for Project, basic outline

.equ DELAY_S = 64                       ; sleep 1 second

.equ patternAddress = 0x0100		; starting address for pattern
.equ patternLength = 50			; default pattern length

.def scoreKeep = r21
.def patternLengthForRound = r22
.def buttonInputValue = r25

.org 0x0000
          jmp       main
          
; ------------------------------------------------------------
main:
; main application method
;         one-time setup & configuration

; set ups for output and input
                                 ; setup 4 pins for output to light
	sbi	DDRB, DDB0	 ; LED 1
	sbi	DDRB, DDB1       ; LED 2
	sbi	DDRB, DDB2       ; LED 3
	sbi	DDRB, DDB3       ; LED 4

				; set 4 light pins to low voltage
	cbi     PORTB, PB0	
	cbi     PORTB, PB1
	cbi     PORTB, PB2
	cbi     PORTB, PB3
	
				; setup different 4 pins for input to the machine, to match light
	cbi	DDRD, DDD0	; Button 1
	cbi	DDRD, DDD1	; Button 2
	cbi	DDRD, DDD2	; Button 3
	cbi	DDRD, DDD3	; Button 4
	
;setup connection with 4 digit display, to keep track of score
	
	ldi	r16, patternLength		;set variable with length value
	mov	r3, r16
	
	ldi	scoreKeep, 0		;set up variable for keeping track of score

	ldi	patternLengthForRound, 1

generate_pattern:
;generates pattern to be utilized in gameplay loop
	ldi	zh, HIGH(patternAddress)	;copy address to z pointer, in order to increment in loop
	ldi	zl, LOW(patternAddress)
	
	ldi	r19, 0		; set up counter for loop

add_into_pattern:
	
				;random generation of value between 1 and 4, assigned to gpr address
				
	cpi	r20, 0			;switch statement determining which signal to save into pattern list
	breq	save_PD0_on_into_pattern
	
	cpi	r20, 1			;switch statement determining which signal to save into pattern list
	breq	save_PD1_on_into_pattern
	
	cpi	r20, 2			;switch statement determining which signal to save into pattern list
	breq	save_PD2_on_into_pattern
	
	cpi	r20, 3			;switch statement determining which signal to save into pattern list
	breq	save_PD3_on_into_pattern
	
	
save_PD0_on_into_pattern:
	ldi	r16, 0b0001
	st	z+, r16			;increments to next address in I/O
	rjmp	continue_pattern_generation
	
save_PD1_on_into_pattern:
	ldi	r16, 0b0010		
	st	z+, r16			;increments to next address in I/O
	rjmp	continue_pattern_generation
	
save_PD2_on_into_pattern:
	ldi	r16, 0b0100
	st	z+, r16			;increments to next address in I/O
	rjmp	continue_pattern_generation
	
save_PD3_on_into_pattern:
	ldi	r16, 0b1000
	st	z+, r16			;increments to next address in I/O
	

continue_pattern_generation:
	
	inc	r19
	cpi	r19, patternLength	;loop for total of 50 times
	breq	main_gameplay_loop
	rjmp	add_into_pattern

; ------------------------------------------------------------
	
main_gameplay_loop:
                               
four_button_press:                      
;the purpose of four_button_press is to take button input, turn led on, turn led off                                   
          in        r16,PORTD           ; copy the entire D port into r16     
          cpi       PD0,1               ; use CPI to check if Port D Pin 0 (button1) is set (pressed)
          breq      button_one_pressed  ; if pressed branch
          cpi       PD1,1               ; use CPI to check if Port D Pin 1 (button2) is set (pressed) 
          breq      button_two_pressed
          cpi       PD2,1               ; use CPI to check if Port D Pin 2 (button3) is set (pressed)
          breq      button_three_pressed
          cpi       PD3,1               ; use CPI to check if Port D Pin 3 (button4) is set (pressed)
          breq      button_four_pressed
          rjmp      four_button_press
button_one_pressed:
          sbi       PORTB,PB0           ; turn LED 1 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB0           ; turn LED 1 off
          rjmp      end_fbpress
button_two_pressed:
          sbi       PORTB,PB1           ; turn LED 2 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB1           ; turn LED 2 off
          rjmp      end_fbpress
button_three_pressed:
          sbi       PORTB,PB2           ; turn LED 3 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB2           ; turn LED 3 off
          rjmp      end_fbpress
button_4_pressed:
          sbi       PORTB,PB3           ; turn LED 4 on
          call      delay_ms            ; sleep(n)
          cbi       PORTB,PB3           ; turn LED 4 off
          rjmp      end_fbpress
end_fbpress:
                                          
	;display value of score
	mov	 r23, patternLengthForRound	;setup register for looping display pattern
	ldi	zh, HIGH(patternAddress)	;copy address to z pointer, in order to increment in loop
	ldi	zl, LOW(patternAddress)

display_pattern: 
	  ld	    r16, z+		;do: fetch value from memory using first memory + (pattern length - 1)
	  				;also increments to next place in pattern
	  cpi	    r16, 0b0001		;display value by turning on corresponding light
	  breq      turn_PB0_on
	  
	  cpi	    r16, 0b0010		
	  breq      turn_PB1_on
	  
	  cpi	    r16, 0b0100		
	  breq      turn_PB2_on
	  
	  cpi	    r16, 0b1000		
	  breq      turn_PB3_on

turn_PB0_on:
	  sbi	    PORTB, PB0
	  rjmp      continue_display_pattern

turn_PB1_on:
	  sbi	    PORTB, PB1
	  rjmp      continue_display_pattern	  
  
turn_PB2_on:
	  sbi	    PORTB, PB2
	  rjmp      continue_display_pattern	  
	  
turn_PB3_on:
	  sbi	    PORTB, PB3
	  
continue_display_pattern:	  	  
	  
	  rjmp      delay_ms		;delay
	  
	  cbi     PORTB, PB0		;turn light off
	  cbi     PORTB, PB1
	  cbi     PORTB, PB2
	  cbi     PORTB, PB3	
	  		
	  inc	  r23			;increment variable to track loop
	  cpse	  r23, patternForLengthRound		;while (loop tracker < pattern length), jump to display_pattern
	  rjmp	  display_pattern
	
	  ldi	  r23, 0		;set loop variable back to zero

player_repeat_pattern:
	  ld	  r16, z+		;do: fetch value from memory using first memory + (pattern length - 1)
	  				;also increments to next place in pattern
	  				
	  	  			;have player input value
					;display light as on
	  cp	  buttonInputValue, r16	;compare player input to value from memory
	  brne    lose_game		;if not same value, jump to lose state
					;else continue loop
	  		
	  inc	  r23			;increment variable tracker
	  cpse	  r23, patternForLengthRound		;while (loop tracker < pattern length), jump to player_repeat_pattern
	  rjmp	  player_repeat_pattern
	  
	  inc	  scoreKeep 		;increment score

end_main:
	inc	patternLengthForRound
	cpi	patternForLengthRound, patternLength + 1
	breq	win_game
	rjmp	main_gameplay_loop

win_game:
	rjmp	win_game

lose_game:
	rjmp	lose_game

; ------------------------------------------------------------
delay_ms:
; creates a timed delay using multiple nested loops (utilized from GPIO tutorials)
; ------------------------------------------------------------
          ldi       r18,DELAY_S
delay_ms_1:

          ldi       r17,200
delay_ms_2:

          ldi       r16,250
delay_ms_3:
          nop
          nop
          dec       r16
          brne      delay_ms_3          ; 250 * 5 = 1250

          dec       r17
          brne      delay_ms_2          ; 200 * 1250 = 250K

          dec       r18
          brne      delay_ms_1          ; 16 * 250K = 4M (1/4s ex)
delay_ms_end:
          ret
